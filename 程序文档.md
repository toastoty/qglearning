## 程序文档

### 单/双链表ADT

#### 问题描述

个人理解：初步实现以下功能：

1. 添加节点
2. 删除节点
3. 节点排序
4. 打印链表
5. 迭代反转
6. 递归反转
7. 奇偶调换
8. 判断成环
9. 找到链表中点（未完成）



**在以下文档中括号内的文字为双向链表的操作补充。**



#### 程序入口/框架

程序使用菜单进行调用

用switch函数进行选择，用循环保证程序运行，只提供一个退出出口。

#### 函数

##### 插入节点

1. 判断头结点是否为空，是则创建头节点，否则在头节点后链接新的节点
2. 将newNode->next置空（将newNode->previous链接到前一个节点）

##### 删除节点

1. 判断删除的是否为头节点，若是则直接将头节点向前移动（将head->next->previous置空）
2. 遍历链表找到需删除节点，用临时变量保存地址，将前一节点的next链接至需删除节点的后一节点（将后一节点的previous链接至前一节点）
3. 将需要删除的节点内的指针置空，释放内存

##### 节点排序

我使用了类似冒泡排序的方法，偷懒使用的值传递

##### 打印链表

1. 判断头指针，若头指针为空，打印提醒
2. 遍历链表打印

##### 迭代反转

1. 判断头节点/第二个节点是否为空，空则直接return
2. 加入指针 prev(储存前一节点) cur(储存当前节点) 
3. 进行指针变换

   - 使用临时变量tmp 储存cur->next
   - 将cur->next指向prev
   - 将pre 与cur 前进: prev = cur; cur = tmp;
4. 循环迭代至链表结束

##### 递归反转

1. 判断头节点/第二个节点是否为空，空则直接return
2. 不断将节点移到头节点前,head->next->next=head;
3. 将head->next置空

##### 奇偶调换

1. 引入两个指针，p1=head;p2=head->next;

2. 每次前进两个节点，将每一次的p1与p2调换
3. 遍历链表



##### 判断成环

1. 引入快慢指针，快指针每次移动两个节点，慢指针每次移动一个节点

2. 在快指针指向空之前判断相遇，若相遇则成环

（若为双向链表，还需要判断previous指针是否成环）

##### 找到中点

1. 引入快慢指针
2. 当快指针指向空时，慢指针所指的节点减一为中间节点
3. 考虑节点个数的奇偶性，若快指针所指的下一位为空，则此时为奇数，反之为偶数，需要输出中间两个节点。

   

#### 数据储存

临时存储，未使用文件流。



## 思考和小结

没有学明白C++，之前写的代码数量太少，靠着薄弱的C语言支撑着写下去，很多地方都没有用上C++的特性，C++学的不够好，所以捉襟见肘。

对于双向链表的操作，有很多功能完全没有用到双向链表的特性，之后需要好好了解一下双链表，这两天虽然也搜索了很多网页，但大多是关于C++语法，因为在这之前完全没有正经用C++写一个完整的程序，很多地方处理的很粗糙。

打算有时间再修改一下这个程序，实在是一团糟。